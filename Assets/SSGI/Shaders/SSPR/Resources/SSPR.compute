#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

RWTexture2D<half4> _SSPRReflectionTexture;
RWTexture2D<float> _SSPRHeightBuffer;

Texture2D<float4> _CameraColorTexture;
Texture2D<float4> _CameraDepthTexture;

SAMPLER(sampler_CameraDepthTexture);
SAMPLER(sampler_CameraColorTexture);

float4 _SSPRReflectionSize;
float _ReflectPlaneHeight;
float4 _CameraDirection;

float4 _StretchParams;
#define STRETCHINTENSITY _StretchParams.x
#define STRETCHTHRESHOLD _StretchParams.y

float _EdgeFadeOut;

float SdfCube(float2 pos)
{
    float2 dis = abs(pos) - float2(1, 1);
    return length(max(dis, 0.0)) - min(max(dis.x, dis.y), 0.0);
}

#pragma kernel SSPR
[numthreads(8,8,1)]
void SSPR(uint3 id : SV_DispatchThreadID)
{
    // 初始化buffer
    _SSPRReflectionTexture[id.xy] = half4(0.0, 0.0, 0.0, 0.0);
    _SSPRHeightBuffer[id.xy] = HALF_MAX;

    // 计算屏幕uv DispatchThreadID：当前线程组在所有线程组里的ID，即图像pos
    float2 uv = id.xy * _SSPRReflectionSize.zw;

    float depth = _CameraDepthTexture.SampleLevel(sampler_CameraDepthTexture, uv, 0).r;
    float linearDepth = Linear01Depth(depth, _ZBufferParams);
    if (linearDepth > 0.99) return; // 跳过天空盒

    // 根据深度还原世界坐标
    float3 wpos = ComputeWorldSpacePosition(uv, depth, UNITY_MATRIX_I_VP);
    if (wpos.y < _ReflectPlaneHeight) return;

    // 计算反射后的世界坐标
    float3 rwpos = wpos;
    rwpos.y = -rwpos.y + 2 * _ReflectPlaneHeight;

    // 计算反射后的uv
    float4 rcpos = TransformWorldToHClip(rwpos);
    float2 ruv = float2(rcpos.x, rcpos.y * _ProjectionParams.x) * rcp(rcpos.w) * 0.5 + 0.5;
    if (any(ruv) < 0.0 || any(ruv) > 1.0) return;

    // 像素距离水面越高越往屏幕两边拽
    float HeightStretch = abs(rwpos.y - _ReflectPlaneHeight);
    // 把屏幕做对称操作，然后在屏幕两边一定范围内做这个操作
    float ScreenStretch = saturate(abs(ruv.x * 2.0 - 1.0) - STRETCHTHRESHOLD);
    // 如果水平角度看水面则没有像素拉伸的操作，角度越大越强
    float AngleStretch = saturate(-_CameraDirection.z);
    AngleStretch = 1.0;
    // ScreenStretch = 1.0;
    // remap to [-1, 1]
    ruv.x = ruv.x * 2.0 - 1.0;
    // stretch
    ruv.x *= 1 + saturate(1 - abs(HeightStretch * AngleStretch * ScreenStretch)) * STRETCHINTENSITY;
    // remap to [0, 1]
    ruv.x = saturate(ruv.x * 0.5 + 0.5);

    // 计算反射后的索引
    float2 rid = ruv * _SSPRReflectionSize.xy;

    // 高度测试 写入更低的颜色
    if (wpos.y >= _SSPRHeightBuffer[rid]) return;

    // 写入深度和颜色
    float mask = SdfCube(uv * 2.0 - 1.0);
    mask = Smootherstep(0, _EdgeFadeOut, abs(mask));

    _SSPRHeightBuffer[rid] = wpos.y;
    _SSPRReflectionTexture[rid] = float4(_CameraColorTexture.SampleLevel(sampler_CameraColorTexture, uv, 0).rgb, mask);
}

#pragma kernel FillHole
[numthreads(8,8,1)]
void FillHole(uint3 id : SV_DispatchThreadID)
{
    // fill holes inside each 2*2
    id.xy *= 2;

    // cache read
    half4 center = _SSPRReflectionTexture[id.xy + uint2(0, 0)];
    half4 right = _SSPRReflectionTexture[id.xy + uint2(0, 1)];
    half4 bottom = _SSPRReflectionTexture[id.xy + uint2(1, 0)];
    half4 bottomRight = _SSPRReflectionTexture[id.xy + uint2(1, 1)];

    // find best inside 2*2
    half4 best = center;
    best = right.a > best.a + 0.5 ? right : best;
    best = bottom.a > best.a + 0.5 ? bottom : best;
    best = bottomRight.a > best.a + 0.5 ? bottomRight : best;

    // write better rgba
    _SSPRReflectionTexture[id.xy + uint2(0, 0)] = best.a > center.a + 0.5 ? best : center;
    _SSPRReflectionTexture[id.xy + uint2(0, 1)] = best.a > right.a + 0.5 ? best : right;
    _SSPRReflectionTexture[id.xy + uint2(1, 0)] = best.a > bottom.a + 0.5 ? best : bottom;
    _SSPRReflectionTexture[id.xy + uint2(1, 1)] = best.a > bottomRight.a + 0.5 ? best : bottomRight;
}
